# CDK Unit Tests Summary

## Table of Contents
- [Overview](#overview)
  - [Test Methodology](#test-methodology)
  - [Test Results](#test-results)
- [Test Execution](#test-execution)
- [NetworkStack Tests (9 tests)](#networkstack-tests-9-tests)
- [MessagingStack Tests (14 tests)](#messagingstack-tests-14-tests)
- [DatabaseStack Tests (11 tests)](#databasestack-tests-11-tests)
- [ApplicationStack Tests (25 tests)](#applicationstack-tests-25-tests)
- [Test Patterns and Best Practices](#test-patterns-and-best-practices)
  - [Testing Methodology](#testing-methodology)
  - [CDK Assertions Library](#cdk-assertions-library)
  - [Test Structure and Organization](#test-structure-and-organization)
  - [Why Template Testing Works](#why-template-testing-works)
- [CI/CD Integration](#cicd-integration)
- [Test Coverage](#test-coverage)

## Overview

This document provides comprehensive documentation for all AWS CDK infrastructure unit tests. The test suite validates CloudFormation templates generated by CDK constructs to ensure infrastructure components are correctly configured, properly connected, and follow AWS best practices.

### Test Methodology

The unit tests use a **template-based validation approach** where each test:

1. **Synthesizes** the CDK stack into CloudFormation templates
2. **Asserts** specific resource properties, counts, and configurations
3. **Validates** IAM permissions, security configurations, and networking
4. **Verifies** stack outputs required for cross-stack references

This approach catches infrastructure misconfigurations early in the development cycle, before deployment to AWS. Tests run in seconds and provide immediate feedback on infrastructure changes.

### Test Results

**Test Framework:** Jest with AWS CDK Assertions Library
**Total Test Suites:** 4
**Total Tests:** 59
**Execution Time:** ~2.1 seconds
**Status:** All passing

---

## Test Execution

### Run All Tests
```bash
npm test                    # Run all 59 tests
npm test -- --coverage      # With coverage report
npm test -- --watch         # Watch mode for development
```

### Run Specific Stack Tests
```bash
npm test -- test/stacks/network-stack.test.ts      # 9 tests
npm test -- test/stacks/database-stack.test.ts     # 11 tests
npm test -- test/stacks/messaging-stack.test.ts    # 14 tests
npm test -- test/stacks/application-stack.test.ts  # 25 tests
```

---

## NetworkStack Tests (9 tests)

**File:** `test/stacks/network-stack.test.ts`

**Purpose:** Validates VPC configuration, subnet architecture, NAT gateways, internet connectivity, and network monitoring infrastructure.

| Test Category | Test Name | Validation |
|--------------|-----------|------------|
| **VPC Configuration** | creates VPC with correct CIDR block | CIDR `10.0.0.0/16`, DNS hostnames enabled, DNS support enabled |
| | creates VPC with 3 availability zones | High availability across 3 AZs |
| | creates public subnets | 6 total subnets (3 public + 3 private) |
| | creates NAT gateways for private subnets | 3 NAT gateways for egress-only internet access |
| | creates internet gateway | Internet gateway attached for public subnet routing |
| **VPC Flow Logs** | enables VPC flow logs | Flow logging enabled for security monitoring |
| | creates CloudWatch log group for flow logs | Logs sent to CloudWatch with proper retention |
| **Stack Outputs** | exports VPC ID | VPC ID available for cross-stack references |
| | exports VPC CIDR | VPC CIDR block exported for security group rules |

**Key Validations:**
- Multi-AZ deployment ensures high availability and fault tolerance
- Private subnet isolation protects compute and database resources
- VPC Flow Logs provide network traffic visibility for security analysis
- Properly configured DNS enables service discovery within the VPC

---

## MessagingStack Tests (14 tests)

**File:** `test/stacks/messaging-stack.test.ts`

**Purpose:** Validates SQS queue configuration, Lambda order producer, IAM permissions, and message processing infrastructure.

| Test Category | Test Name | Validation |
|--------------|-----------|------------|
| **SQS Queue Configuration** | creates main order queue | Name: `orders-queue`, visibility timeout: 300s, long polling: 20s |
| | enables encryption at rest | SSE-SQS (SQS-managed encryption) enabled |
| | creates dead letter queue | Name: `orders-dlq`, retention: 14 days |
| | configures DLQ redrive policy | Failed messages retry 3 times before DLQ |
| **Lambda Function** | creates order producer Lambda | Runtime: Python 3.11, handler: `index.handler`, timeout: 30s |
| | Lambda has environment variables | `QUEUE_URL` environment variable configured |
| **IAM Permissions** | Lambda has permission to send messages to SQS | Policy grants `sqs:SendMessage` action |
| | Lambda execution role exists | Lambda can assume role via `sts:AssumeRole` |
| **Stack Outputs** | exports queue URL | Main queue URL available for cross-stack reference |
| | exports queue ARN | Main queue ARN exported |
| | exports DLQ URL | Dead letter queue URL exported |
| | exports Lambda function ARN | Order producer Lambda ARN exported |
| **Resource Count** | creates exactly 2 SQS queues | Main queue + DLQ only (no extras) |
| | creates exactly 1 Lambda function | Order producer Lambda only |

**Key Validations:**
- Long polling (20s) reduces API costs and improves message delivery latency
- Visibility timeout (5 minutes) allows sufficient processing time before message reappears
- DLQ redrive policy prevents infinite retry loops and captures permanently failed messages
- Encryption at rest ensures message data is protected in SQS storage
- IAM least privilege ensures Lambda has only necessary SQS permissions

---

## DatabaseStack Tests (11 tests)

**File:** `test/stacks/database-stack.test.ts`

**Purpose:** Validates Aurora Serverless v2 PostgreSQL configuration, backup policies, encryption, and high availability deployment.

| Test Category | Test Name | Validation |
|--------------|-----------|------------|
| **Aurora Serverless v2 Cluster** | creates Aurora cluster with PostgreSQL engine | Engine: `aurora-postgresql`, min: 0.5 ACU, max: 1 ACU |
| | configures backup retention | 7-day retention for point-in-time recovery |
| | sets database name | Default database: `orders` |
| **Database Instances** | creates writer instance | Class: `db.serverless`, engine: `aurora-postgresql` |
| | configures instances in private subnets | No public accessibility, private subnet only |
| **Secrets Manager** | creates secret for database credentials | Master password stored in Secrets Manager |
| **Stack Outputs** | exports cluster endpoint | Writer endpoint for read/write operations |
| | exports cluster read endpoint | Read-only endpoint for query scaling |
| | exports secret ARN | Secret ARN for application credential retrieval |
| | exports database name | Database name available for connection strings |
| **High Availability** | cluster is deployed in multiple AZs | DB subnet group spans multiple AZs |

**Key Validations:**
- Serverless v2 scales from 0.5 ACU (minimum cost) to 1 ACU (sufficient for dev workload)
- Private subnet deployment prevents direct internet access to database
- 7-day backup retention enables recovery from accidental data changes
- Secrets Manager integration eliminates hardcoded credentials
- Multi-AZ subnet group enables automatic failover for high availability
- Separate reader endpoint allows read scaling without impacting writer performance

---

## ApplicationStack Tests (25 tests)

**File:** `test/stacks/application-stack.test.ts`

**Purpose:** Validates ECS Fargate compute infrastructure, Application Load Balancer configuration, auto-scaling policies, and IAM security permissions.

| Test Category | Test Name | Validation |
|--------------|-----------|------------|
| **ECS Cluster** | creates ECS cluster | Cluster name: `order-processing-cluster` |
| | enables Fargate capacity providers | Fargate capacity providers enabled |
| **Application Load Balancer** | creates ALB | Internet-facing ALB for public access |
| | creates HTTP listener on port 80 | Listener on port 80 for HTTP traffic |
| | creates target group for backend | Port 3000, health check: `/api/health` |
| | creates target group for frontend | Port 80, health check: `/` |
| **Backend ECS Service** | creates Fargate task definition | CPU/memory allocation configured |
| | task definition has backend container | ECR image reference configured |
| | creates ECS service with desired count | Appropriate task count for workload |
| | service has circuit breaker enabled | Automatic rollback on failed deployments |
| **Frontend ECS Service** | creates frontend task definition | Task definition properly configured |
| | creates frontend service | ECS service running in private subnets |
| **Auto Scaling** | creates auto scaling target for backend | Auto-scaling enabled for backend service |
| | creates CPU scaling policy | Target: 80% CPU utilization |
| | creates memory scaling policy | Target: 85% memory utilization |
| **IAM Roles & Permissions** | creates task execution role | ECS task execution role exists |
| | backend task role has SQS permissions | Permissions: ReceiveMessage, DeleteMessage, SendMessage |
| | backend task role has Secrets Manager permissions | Permission: GetSecretValue for DB credentials |
| **Stack Outputs** | exports ALB URL | Load Balancer URL for application access |
| | exports ALB DNS | ALB DNS name exported |
| | exports backend service name | Backend service name for monitoring |
| | exports frontend service name | Frontend service name for monitoring |
| **Resource Count** | creates 2 ECS services | Backend + frontend services only |
| | creates 2 target groups | Backend + frontend target groups only |
| | creates 1 load balancer | Single ALB for traffic distribution |

**Key Validations:**
- Circuit breaker prevents cascading failures by automatically rolling back bad deployments
- Auto-scaling policies ensure application scales based on actual resource utilization
- IAM least privilege grants only necessary permissions to each service
- Health checks on both target groups enable automatic traffic routing to healthy tasks
- Private subnet deployment protects application tier from direct internet access
- Stack outputs enable cross-stack references and external integrations

---

## Test Patterns and Best Practices

### Testing Methodology

The test suite follows a **template-driven testing approach** where CDK constructs are synthesized into CloudFormation templates, and assertions validate the generated resources. This methodology provides several advantages:

**Early Detection:** Infrastructure bugs are caught during development, not deployment. A misconfigured security group or missing IAM permission is identified in seconds during test execution, rather than minutes or hours during AWS deployment.

**Regression Prevention:** Once a test validates a specific configuration (e.g., VPC Flow Logs enabled), any code change that breaks this functionality immediately fails the test, preventing accidental removal of critical features.

**Documentation as Code:** Tests serve as executable documentation. Reading the test suite clearly shows what infrastructure is deployed and how components are configured.

**Fast Feedback Loop:** All 59 tests complete in ~2 seconds, enabling rapid iteration during development without waiting for AWS API calls.

### CDK Assertions Library

The AWS CDK Assertions library provides a fluent API for validating CloudFormation templates. Common patterns include:

```typescript
import { Template, Match } from 'aws-cdk-lib/assertions';

// Synthesize CDK stack into CloudFormation template
const template = Template.fromStack(stack);

// Assert exact resource properties
template.hasResourceProperties('AWS::SQS::Queue', {
  QueueName: 'orders-queue',
  VisibilityTimeout: 300,
});

// Assert resource count (prevents accidental duplication)
template.resourceCountIs('AWS::EC2::NatGateway', 3);

// Assert stack outputs (required for cross-stack references)
template.hasOutput('QueueUrl', {});

// Use matchers for flexible assertions
template.hasResourceProperties('AWS::IAM::Policy', {
  PolicyDocument: {
    Statement: Match.arrayWith([
      Match.objectLike({
        Action: Match.arrayWith(['sqs:SendMessage']),
      }),
    ]),
  },
});
```

**Key Assertion Methods:**
- `hasResourceProperties()` - Validates specific resource configuration
- `resourceCountIs()` - Ensures exact number of resources (no extras)
- `hasOutput()` - Confirms stack exports required outputs
- `Match.arrayWith()` - Flexible matching for arrays (order-independent)
- `Match.objectLike()` - Partial object matching (allows additional properties)

### Test Structure and Organization

Tests follow a consistent structure that groups related validations and uses descriptive test names:

```typescript
describe('StackName', () => {
  let app: App;
  let stack: StackName;
  let template: Template;

  beforeEach(() => {
    // Setup: Create fresh stack instance for each test
    app = new App();
    stack = new StackName(app, 'TestStack', { /* props */ });
    template = Template.fromStack(stack);
  });

  describe('Feature Group', () => {
    test('validates specific configuration', () => {
      template.hasResourceProperties('AWS::Service::Type', {
        Property: 'ExpectedValue',
      });
    });
  });
});
```

**Organizational Principles:**
- **Isolated Tests:** Each test uses `beforeEach()` to create fresh stack instances, preventing test interdependence
- **Descriptive Names:** Test names clearly describe what is validated (e.g., "creates VPC with 3 availability zones")
- **Logical Grouping:** Related tests are grouped using `describe()` blocks (e.g., "VPC Configuration", "IAM Permissions")
- **Single Assertion Focus:** Each test validates one specific aspect, making failures easy to diagnose

### Why Template Testing Works

Template-based testing validates the **desired state** defined by infrastructure code without requiring actual AWS resources. This approach:

1. **Eliminates AWS Costs:** No test environments or temporary resources needed
2. **Enables Rapid Iteration:** Tests run in CI/CD pipeline without AWS credentials
3. **Validates Intent:** Confirms infrastructure code generates expected CloudFormation
4. **Catches Drift:** Changes to CDK constructs are immediately tested against expected outputs

However, template testing has limitations:
- **Doesn't validate AWS API behavior:** Assumes CloudFormation will successfully create resources
- **Doesn't test resource limits:** Can't detect if requested instance types are available
- **Doesn't validate cross-stack integration:** Tests individual stacks in isolation

For comprehensive validation, template tests should be complemented with integration tests that deploy to actual AWS environments.

---

## CI/CD Integration

Tests run automatically in GitHub Actions pipeline on every push to develop branch:

```yaml
- name: Run unit tests
  run: npm test -- --coverage --ci

- name: Publish test results
  uses: EnricoMi/publish-unit-test-result-action@v2
  if: always()
  with:
    files: '**/test-results.xml'
    check_name: CDK Unit Tests
```

**Test Results:** All 59 tests pass in ~2.1 seconds

---

## Test Coverage

All infrastructure components are validated:

- **Networking:** VPC, subnets, NAT gateways, security groups, VPC Flow Logs
- **Compute:** ECS cluster, Fargate services, task definitions, auto-scaling
- **Load Balancing:** ALB, target groups, listeners, health checks
- **Data Storage:** Aurora Serverless v2, backups, encryption, multi-AZ
- **Messaging:** SQS queues, Dead Letter Queue, Lambda producer
- **Security:** IAM roles, encryption at rest/transit, Secrets Manager
- **Stack Outputs:** All cross-stack references validated
